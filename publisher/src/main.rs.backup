use chrono::Local;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

const MQTT_BROKER: &str = "test.mosquitto.org";
const MQTT_PORT: u16 = 1883;

fn main() -> std::io::Result<()> {
    log("Publisher starting...");
    let mut stream = TcpStream::connect((MQTT_BROKER, MQTT_PORT))?;
    stream.set_read_timeout(Some(Duration::from_secs(5)))?;
    log("Connected to MQTT broker");

    let connect = connect_packet("PublisherClient");
    stream.write_all(&connect)?;
    log(&format!("Sent CONNECT packet: {:02X?}", connect));

    let mut connack = [0u8; 4];
    stream.read_exact(&mut connack)?;
    log(&format!("Received CONNACK: {:02X?}", connack));

    if connack[3] != 0 {
        log("Connection refused. Exiting.");
        return Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "Connection refused",
        ));
    }

    for i in 1..=10 {
        let message = format!("Hello from publisher {}", i);
        let publish = publish_packet("test/topic", &message);
        stream.write_all(&publish)?;
        log(&format!("Published message: {}", message));
        thread::sleep(Duration::from_secs(5));
    }

    let disconnect = disconnect_packet();
    stream.write_all(&disconnect)?;
    log("Sent DISCONNECT packet.");

    Ok(())
}

fn connect_packet(client_id: &str) -> Vec<u8> {
    let mut packet = vec![0x10, 0, 0, 4, b'M', b'Q', b'T', b'T', 4, 2, 0, 60];
    let client_id_bytes = client_id.as_bytes();
    packet.extend_from_slice(&(client_id_bytes.len() as u16).to_be_bytes());
    packet.extend_from_slice(client_id_bytes);
    packet[1] = (packet.len() - 2) as u8;
    packet
}

fn publish_packet(topic: &str, message: &str) -> Vec<u8> {
    let mut packet = vec![0x30];
    let mut vh_payload = Vec::new();
    let topic_bytes = topic.as_bytes();
    vh_payload.extend_from_slice(&(topic_bytes.len() as u16).to_be_bytes());
    vh_payload.extend_from_slice(topic_bytes);
    vh_payload.extend_from_slice(message.as_bytes());

    let rem_len = encode_remaining_length(vh_payload.len());
    packet.extend(rem_len);
    packet.extend(vh_payload);
    packet
}

fn disconnect_packet() -> Vec<u8> {
    vec![0xE0, 0x00]
}

fn encode_remaining_length(mut length: usize) -> Vec<u8> {
    let mut encoded_bytes = Vec::new();
    loop {
        let mut byte = (length % 128) as u8;
        length /= 128;
        if length > 0 {
            byte |= 0x80;
        }
        encoded_bytes.push(byte);
        if length == 0 {
            break;
        }
    }
    encoded_bytes
}

fn log(msg: &str) {
    let now = Local::now().format("%Y-%m-%d %H:%M:%S");
    println!("[{}] {}", now, msg);
}
